<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Wed Feb 26 14:51:01 EST 2003 -->
<TITLE>
Connection
</TITLE>
<META NAME="keywords" CONTENT="foldocml.Connection,Connection class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Connection";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../foldocml/AvgNormSearchPenalty.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../foldocml/DiffDistance.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Connection.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
foldocml</FONT>
<BR>
Class Connection</H2>
<PRE>
java.lang.Object
  |
  +--<B>foldocml.Connection</B>
</PRE>
<HR>
<DL>
<DT>public class <B>Connection</B><DT>extends java.lang.Object</DL>

<P>
This class provides the API to the MECUREO toolset
 <p>
 It provides access to an [already parsed] ontology in order to
 perform queries on it. For example, to generate or compare user models in the
 context of the ontology, a connection is created to represent the ontology from
 the ontology file using <code>connect</code>. <code>generate</code> is called
 with a iterator of keywords to generate any number of models. These models may
 then be compared using one of the <code>ratioSimilar</code> functions.
 </p>
 <p> </p>
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>0.4</DD>
<DT><B>Author:</B></DT>
  <DD>Trent Apted</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../foldocml/Connection.html#Connection(hashgraph.HashGraph)">Connection</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;ontology)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a connection interface for the given model.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../foldocml/Connection.html">Connection</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#connect(java.io.File)">connect</A></B>(java.io.File&nbsp;ontologyGraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a connection to the ontology stored in <code>ontologyGraph</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#depthgrow(java.util.Iterator, double)">depthgrow</A></B>(java.util.Iterator&nbsp;words,
          double&nbsp;ddepth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#generate(java.util.Iterator, double, double, java.io.PrintWriter)">generate</A></B>(java.util.Iterator&nbsp;words,
         double&nbsp;distance,
         double&nbsp;infinity,
         java.io.PrintWriter&nbsp;log)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>the preferred way to generate a model is now <code>grow</code> -
 it uses a more intelligent procedure that is able to make use of 'focal points'
 inherent in the word list [ie where a number of the words on the word list
 are from a small region in the ontology].</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#grow(java.util.Iterator, double)">grow</A></B>(java.util.Iterator&nbsp;words,
     double&nbsp;depth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a [user] model using this <code>Connection</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#grow(java.util.Iterator, double, int)">grow</A></B>(java.util.Iterator&nbsp;words,
     double&nbsp;depth,
     int&nbsp;maxNodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#openGraph(java.io.File)">openGraph</A></B>(java.io.File&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open a model (or ontology) stored in the proprietary format in <code>graph</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#outputDOT(hashgraph.HashGraph)">outputDOT</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output a model as [textual] 'dot' language to standard output using default settings
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#outputDOT(hashgraph.HashGraph, java.io.PrintWriter)">outputDOT</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
          java.io.PrintWriter&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output a model as dot to the specified <code>PrintWriter</code> without
 clustering and with 0 minumum kids/peerage</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#outputDOT(hashgraph.HashGraph, java.io.PrintWriter, boolean, int, int)">outputDOT</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
          java.io.PrintWriter&nbsp;out,
          boolean&nbsp;cluster,
          int&nbsp;minKids,
          int&nbsp;minLinks)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output a model as [textual] dot language to the specified output stream with optional clustering into three clusters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#outputDOT(hashgraph.HashGraph, java.io.PrintWriter, int)">outputDOT</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
          java.io.PrintWriter&nbsp;out,
          int&nbsp;minPeers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output a model as dot to the specified <code>PrintWriter</code> without
 clustering and with minKids = minLinks = minPeers</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#outputDOT(hashgraph.HashGraph, java.io.PrintWriter, int, int)">outputDOT</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
          java.io.PrintWriter&nbsp;out,
          int&nbsp;minKids,
          int&nbsp;minLinks)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output as dot without clustering</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#outputHCI(hashgraph.HashGraph, java.io.PrintWriter)">outputHCI</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
          java.io.PrintWriter&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output a model as VLUM RDF for HCI</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#outputRDF(hashgraph.HashGraph, java.io.PrintWriter)">outputRDF</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
          java.io.PrintWriter&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output a model as [textual] RDF format for VLUM [ie XML] to the specified
 <code>PrintWriter</code>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#ratioSimilar0(hashgraph.HashGraph, java.io.PrintStream)">ratioSimilar0</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
              java.io.PrintStream&nbsp;log)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a <b>Base Nested Similarity</b> analysis<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#ratioSimilar1(hashgraph.HashGraph, hashgraph.HashGraph)">ratioSimilar1</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
              <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a <b>Global Similarity</b> without verbose output</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#ratioSimilar1(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)">ratioSimilar1</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
              <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
              java.io.PrintStream&nbsp;log)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a <b>Global Similarity</b><br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#ratioSimilar2(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)">ratioSimilar2</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
              <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
              java.io.PrintStream&nbsp;log)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a <b>Basic Search Similarity</b><br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#ratioSimilar3(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)">ratioSimilar3</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
              <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
              java.io.PrintStream&nbsp;log)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform an <b>Averaged Search Similarity</b><br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#ratioSimilar4(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)">ratioSimilar4</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
              <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
              java.io.PrintStream&nbsp;log)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a <b>Normalised Search Similarity</b><br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#ratioSimilar5(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)">ratioSimilar5</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
              <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
              java.io.PrintStream&nbsp;log)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform an <b>Averaged Normalised Search Similarity</b><br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#ratioSimilar6(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)">ratioSimilar6</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
              <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
              java.io.PrintStream&nbsp;log)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a <b>Minimum Spanning Tree Similarity</b><br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../foldocml/Connection.html#sizegrow(java.util.Iterator, double)">sizegrow</A></B>(java.util.Iterator&nbsp;words,
         double&nbsp;maxNodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Connection(hashgraph.HashGraph)"><!-- --></A><H3>
Connection</H3>
<PRE>
public <B>Connection</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;ontology)</PRE>
<DL>
<DD>Create a connection interface for the given model.
 <p>
 Note that models and ontologies are interchangeable - indeed a subset of
 the ontology may be used by generating a model and creating a connection
 to it.
 </p>
<P>
<DT><B>Parameters:</B><DD><CODE>ontology</CODE> - the model/ontology to connect to [give an interface for]</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="connect(java.io.File)"><!-- --></A><H3>
connect</H3>
<PRE>
public static <A HREF="../foldocml/Connection.html">Connection</A> <B>connect</B>(java.io.File&nbsp;ontologyGraph)
                          throws java.io.IOException</PRE>
<DL>
<DD>Create a connection to the ontology stored in <code>ontologyGraph</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ontologyGraph</CODE> - the ontology <code>File</code>
<DT><B>Returns:</B><DD>a <code>Connection</code> for <code>ontologyGraph</code>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error</DL>
</DD>
</DL>
<HR>

<A NAME="openGraph(java.io.File)"><!-- --></A><H3>
openGraph</H3>
<PRE>
public static <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>openGraph</B>(java.io.File&nbsp;graph)
                           throws java.io.IOException</PRE>
<DL>
<DD>Open a model (or ontology) stored in the proprietary format in <code>graph</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the model <code>File</code>
<DT><B>Returns:</B><DD>a <code>HashGraph</code> that can be used as a parameter for a <code>Connection</code>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error</DL>
</DD>
</DL>
<HR>

<A NAME="outputDOT(hashgraph.HashGraph, java.io.PrintWriter, boolean, int, int)"><!-- --></A><H3>
outputDOT</H3>
<PRE>
public static void <B>outputDOT</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
                             java.io.PrintWriter&nbsp;out,
                             boolean&nbsp;cluster,
                             int&nbsp;minKids,
                             int&nbsp;minLinks)
                      throws java.io.IOException</PRE>
<DL>
<DD>Output a model as [textual] dot language to the specified output stream with optional clustering into three clusters.
 <p>The clusters are:
 <ul><li>Nodes common</li><li>Nodes only in left</li><li>Nodes only in right</li></ul>
 </p><p>Clustering is only useful after a merge operation on two models<br>
 If minKids &gt; 0 then only nodes with at least <code>minKids</code> <i>forward</i> &nbsp;links will be output<br>
 If minLinks &gt; 0 then only nodes with at least <code>minLinks</code> links in either direction will be output<br>
 In general minKids = minLinks works fine
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the [merged] model to output<DD><CODE>out</CODE> - the <code>PrintWriter</code> stream to output to<DD><CODE>cluster</CODE> - if true then output is clustered<DD><CODE>minKids</CODE> - minimum number of forward links for a node to be output<DD><CODE>minLinks</CODE> - minimum number of peers for a node to be output
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error<DT><B>See Also:</B><DD><A HREF="../foldocparser/Outputter.html#autoDOTCluster(hashgraph.HashGraph, java.io.PrintWriter, int, int)"><CODE>Outputter.autoDOTCluster(HashGraph, PrintWriter, int, int)</CODE></A>, 
<A HREF="../foldocparser/Outputter.html#outputDOT(hashgraph.HashGraph, java.io.PrintWriter, int, int)"><CODE>Outputter.outputDOT(HashGraph, PrintWriter, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="outputDOT(hashgraph.HashGraph)"><!-- --></A><H3>
outputDOT</H3>
<PRE>
public static void <B>outputDOT</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g)
                      throws java.io.IOException</PRE>
<DL>
<DD>Output a model as [textual] 'dot' language to standard output using default settings
 <p>The default settings are for no clustering and 0 minimum peerage</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the model to output
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error<DT><B>See Also:</B><DD><A HREF="../foldocml/Connection.html#outputDOT(hashgraph.HashGraph, java.io.PrintWriter, boolean, int, int)"><CODE>outputDOT(HashGraph, PrintWriter, boolean, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="outputDOT(hashgraph.HashGraph, java.io.PrintWriter, int, int)"><!-- --></A><H3>
outputDOT</H3>
<PRE>
public static void <B>outputDOT</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
                             java.io.PrintWriter&nbsp;out,
                             int&nbsp;minKids,
                             int&nbsp;minLinks)
                      throws java.io.IOException</PRE>
<DL>
<DD>Output as dot without clustering
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the model to output<DD><CODE>out</CODE> - the <code>PrintWriter</code> stream to output to<DD><CODE>minKids</CODE> - minimum number of forward links for a node to be output<DD><CODE>minLinks</CODE> - minimum number of peers for a node to be output
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error<DT><B>See Also:</B><DD><A HREF="../foldocml/Connection.html#outputDOT(hashgraph.HashGraph, java.io.PrintWriter, boolean, int, int)"><CODE>outputDOT(HashGraph, PrintWriter, boolean, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="outputDOT(hashgraph.HashGraph, java.io.PrintWriter)"><!-- --></A><H3>
outputDOT</H3>
<PRE>
public static void <B>outputDOT</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
                             java.io.PrintWriter&nbsp;out)
                      throws java.io.IOException</PRE>
<DL>
<DD>Output a model as dot to the specified <code>PrintWriter</code> without
 clustering and with 0 minumum kids/peerage
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the model to output<DD><CODE>out</CODE> - the <code>PrintWriter</code> stream to output to
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error<DT><B>See Also:</B><DD><A HREF="../foldocml/Connection.html#outputDOT(hashgraph.HashGraph, java.io.PrintWriter, boolean, int, int)"><CODE>outputDOT(HashGraph, PrintWriter, boolean, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="outputDOT(hashgraph.HashGraph, java.io.PrintWriter, int)"><!-- --></A><H3>
outputDOT</H3>
<PRE>
public static void <B>outputDOT</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
                             java.io.PrintWriter&nbsp;out,
                             int&nbsp;minPeers)
                      throws java.io.IOException</PRE>
<DL>
<DD>Output a model as dot to the specified <code>PrintWriter</code> without
 clustering and with minKids = minLinks = minPeers
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the model to output<DD><CODE>out</CODE> - the <code>PrintWriter</code> stream to output to<DD><CODE>minPeers</CODE> - the number minimum number of links=kids as for <code>outputDOT/5</code>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error<DT><B>See Also:</B><DD><A HREF="../foldocml/Connection.html#outputDOT(hashgraph.HashGraph, java.io.PrintWriter, boolean, int, int)"><CODE>outputDOT(HashGraph, PrintWriter, boolean, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="outputRDF(hashgraph.HashGraph, java.io.PrintWriter)"><!-- --></A><H3>
outputRDF</H3>
<PRE>
public static void <B>outputRDF</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
                             java.io.PrintWriter&nbsp;out)
                      throws java.io.IOException</PRE>
<DL>
<DD>Output a model as [textual] RDF format for VLUM [ie XML] to the specified
 <code>PrintWriter</code>
 <p>
 Note that this output may become verbose for large models.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the model to output<DD><CODE>out</CODE> - the <code>PrintWriter</code> stream to output to
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error<DT><B>See Also:</B><DD><A HREF="../foldocparser/Outputter.html#outputRDF(hashgraph.HashGraph, java.io.PrintWriter)"><CODE>Outputter.outputRDF(HashGraph g, PrintWriter out)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="outputHCI(hashgraph.HashGraph, java.io.PrintWriter)"><!-- --></A><H3>
outputHCI</H3>
<PRE>
public static void <B>outputHCI</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g,
                             java.io.PrintWriter&nbsp;out)
                      throws java.io.IOException</PRE>
<DL>
<DD>Output a model as VLUM RDF for HCI
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - <DD><CODE>out</CODE> - 
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE><DT><B>See Also:</B><DD><A HREF="../foldocml/Connection.html#outputRDF(hashgraph.HashGraph, java.io.PrintWriter)"><CODE>outputRDF(HashGraph g, PrintWriter out)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="generate(java.util.Iterator, double, double, java.io.PrintWriter)"><!-- --></A><H3>
generate</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>generate</B>(java.util.Iterator&nbsp;words,
                          double&nbsp;distance,
                          double&nbsp;infinity,
                          java.io.PrintWriter&nbsp;log)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>the preferred way to generate a model is now <code>grow</code> -
 it uses a more intelligent procedure that is able to make use of 'focal points'
 inherent in the word list [ie where a number of the words on the word list
 are from a small region in the ontology].</I>
<P>
<DD>Generate a [user] model using this <code>Connection</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>words</CODE> - an iterator of <code>Object</code>s - for which the <code>.toString()</code>
 method will be used as a basis for <b><i>matching</i></b> &nbsp;a concept in the ontology.<br>
 Current matching involves exact string matches.<DD><CODE>distance</CODE> - the depth of the subgraphs formed for each word<DD><CODE>infinity</CODE> - the <i>node weight</i> &nbsp;penalty for nodes not in the subgraphs formed for other words<DD><CODE>log</CODE> - a <code>PrintWriter</code> text stream where verbose logging information is sent
<DT><B>Returns:</B><DD>the generated model<DT><B>See Also:</B><DD><A HREF="../foldocml/Connection.html#grow(java.util.Iterator, double)"><CODE>grow(Iterator words, double depth)</CODE></A>, 
<A HREF="../foldoccmd/NodeSearch.html"><CODE>NodeSearch</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="grow(java.util.Iterator, double)"><!-- --></A><H3>
grow</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>grow</B>(java.util.Iterator&nbsp;words,
                      double&nbsp;depth)</PRE>
<DL>
<DD>Generate a [user] model using this <code>Connection</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>words</CODE> - an iterator of <code>Object</code>s - for which the <code>.toString()</code>
 method will be used as a basis for <b><i>matching</i></b> a concept in the ontology.
 <blockquote>
 Current matching involves exact string matches. However, <code>foldoccmd.NodeSearch</code>
 is able to perform more complex matching based on word stems and substring
 matches when the word stem match fails. It can convert one iterator of words
 into another, all of whose elements will be exact matches in a given ontology.
 </blockquote><DD><CODE>depth</CODE> - the depth [distance] of the model - any path from a node corresponding
 to a word in <code>words</code> to any other node will be no greater than <code>depth</code>
 minus the <i>node weight</i> &nbsp;of the start node, except where focal
 points [ie where a number of the words on the word list are from a small
 region in the ontology] are identified. Here a 'bonus' is given that will
 allow paths originating from such focal points to be slightly longer
<DT><B>Returns:</B><DD>the generated model<DT><B>See Also:</B><DD><A HREF="../hashgraph/HashGraph.html#grow(java.util.Iterator, double)"><CODE>HashGraph.grow(Iterator words, double depth)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="grow(java.util.Iterator, double, int)"><!-- --></A><H3>
grow</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>grow</B>(java.util.Iterator&nbsp;words,
                      double&nbsp;depth,
                      int&nbsp;maxNodes)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sizegrow(java.util.Iterator, double)"><!-- --></A><H3>
sizegrow</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>sizegrow</B>(java.util.Iterator&nbsp;words,
                          double&nbsp;maxNodes)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="depthgrow(java.util.Iterator, double)"><!-- --></A><H3>
depthgrow</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>depthgrow</B>(java.util.Iterator&nbsp;words,
                           double&nbsp;ddepth)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="ratioSimilar0(hashgraph.HashGraph, java.io.PrintStream)"><!-- --></A><H3>
ratioSimilar0</H3>
<PRE>
public double <B>ratioSimilar0</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
                            java.io.PrintStream&nbsp;log)</PRE>
<DL>
<DD>Perform a <b>Base Nested Similarity</b> analysis<br>
 <p>
 This returns a ratio to represent how similiar <code>g2</code> is with
 the <i>current <code>Connection</code></i> using the same function as
 'Global Similarity'
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g2</CODE> - the model to test<DD><CODE>log</CODE> - if not <code>null</code> where verbose output is sent
<DT><B>Returns:</B><DD>the ratio of how similiar <code>g2</code> is to the connection<DT><B>See Also:</B><DD><A HREF="../foldocml/Connection.html#ratioSimilar1(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)"><CODE>ratioSimilar1(HashGraph g1, HashGraph g2, PrintStream log)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ratioSimilar1(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)"><!-- --></A><H3>
ratioSimilar1</H3>
<PRE>
public double <B>ratioSimilar1</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
                            <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
                            java.io.PrintStream&nbsp;log)</PRE>
<DL>
<DD>Perform a <b>Global Similarity</b><br>
 <p>
 This applies an heuristic using the number of nodes common and not common
 beween g1 and g2, as well as the difference in <i>node weights</i> &nbsp;
 for nodes that are common and a biased penalty function for nodes that are
 not common.
 </p><p>
 It runs in O(|g1| + |g2|)
 </p><p>
 Formally, the value returned is achieved by <br><br>
 <code>commonSimilarity = sum{1 - abs(|l[i]| - |r[j]|)} / |rc|</code>
 <br><br>summed for l[i] == r[j]
 <br>where |rc| == |lc| == the number of nodes common,
 <br>l[i] is the i-th concept in <code>g1</code>
 <br>r[j] is the j-th concept in <code>g2</code>
 <br>|p[k]| is the node weight in p for the k-th concept
 <br><br>
 <code>bias = 1 - min{|lu|, |ru|} / max{|lu|, |ru|}</code>
 <br>
 <code>penalty = 1.5 - (|lu| + |ru|) / (|lu| + |ru| + |rc| + |lc|)</code>
 <br>
 <code>finalSimilarity =  ((bias + penalty)/2)*commonSimilarity</code>
 <br><br>where |lu| is the number of nodes in <code>g1</code> not in <code>g2</code>
 <br>and |ru| is the number of nodes in <code>g2</code> not in <code>g1</code>
 </p><ul>
 <li>This is with the current contribution constants.
 </li><li>The contributions of bias
 and penalty (both separately and together) can be adjusted, but if all
 comparisons are done with the same constants the relative similarities
 returned should be consistent.
 </li><li>'bias' gives a beneficial bias when it is found that one graph is clearly
 a subset of another - this is helpful for <i>classification</i> &nbsp;
 comparisons.
 </li><li>'penalty' penalises the similarity of nodes common [commonSimilarity] by
 determining the ratio of numbers of nodes not common to those common<br>
 In practice small offsets are used to simulate Laplace estimators in case
 any part yeilds zero.
 </li><li>The final similarity returned combines these values [again with adjustable
 contribution constants], heuristically.
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g1</CODE> - the 'left' model<DD><CODE>g2</CODE> - the 'right' model<DD><CODE>log</CODE> - if not <code>null</code>, where verbose output is sent
<DT><B>Returns:</B><DD>the ratio of similarity for <code>g1</code> and <code>g2</code><DT><B>See Also:</B><DD><A HREF="../foldocml/Similarity.html"><CODE>Similarity</CODE></A>, 
<A HREF="../foldocml/DiffDistance.html"><CODE>DiffDistance</CODE></A>, 
<A HREF="../foldocml/PenaltyFunc.html"><CODE>PenaltyFunc</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ratioSimilar1(hashgraph.HashGraph, hashgraph.HashGraph)"><!-- --></A><H3>
ratioSimilar1</H3>
<PRE>
public double <B>ratioSimilar1</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
                            <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2)</PRE>
<DL>
<DD>Perform a <b>Global Similarity</b> without verbose output
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g1</CODE> - the 'left' model<DD><CODE>g2</CODE> - the 'right' model
<DT><B>Returns:</B><DD>the ratio of similarity for <code>g1</code> and <code>g2</code></DL>
</DD>
</DL>
<HR>

<A NAME="ratioSimilar2(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)"><!-- --></A><H3>
ratioSimilar2</H3>
<PRE>
public double <B>ratioSimilar2</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
                            <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
                            java.io.PrintStream&nbsp;log)</PRE>
<DL>
<DD>Perform a <b>Basic Search Similarity</b><br>
 <p>
 This uses the same <code>commonSimilarity</code> value as for Global
 Similarity, but calculates the penalty differently, and is not designed
 to return a value in [0, 1] - the separate values for commonSimilarity
 and penalty are to be used to evaluate the similarity as there is not
 yet a clear way to combine them.
 </p><p>
 For each node in <code>g1</code> not in <code>g2</code> the shortest
 path <i>in the ontology</i> (for this connection) between that node
 and <i>any</i> node in <code>g2</code> is found. A maximum distance
 is specified and if the path exceeds that distance [or there is no path]
 the maximum distance is substituted (the default used here is 5)
 </p><p>
 This, and the other '... Search Similarity' algorithms run in worst case
 that is essentially
 O((|lu| + |ru|)*NlgN), where N is the size of the ontology. However, the
 reality is not really this bad because the maximum distance is able to
 provide early exits for many searches.
 </p><p>
 Formally,<br><br>
 <pre>penalty = sum{min{shortestDist(l[i], r), 5}} +
 &nbsp;        sum{min{shortestDist(r[j], l), 5}}</pre>
 <br><ul><li>for l[i] not in r and r[j] not in l</li></ul>
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g1</CODE> - the 'left' model<DD><CODE>g2</CODE> - the 'right' model<DD><CODE>log</CODE> - if not <code>null</code> where verbose output is sent
<DT><B>Returns:</B><DD>the ratio of similarity for <code>g1</code> and <code>g2</code><DT><B>See Also:</B><DD><A HREF="../foldocml/Similarity.html"><CODE>Similarity</CODE></A>, 
<A HREF="../foldocml/DiffDistance.html"><CODE>DiffDistance</CODE></A>, 
<A HREF="../foldocml/SearchPenalty.html"><CODE>SearchPenalty</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ratioSimilar3(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)"><!-- --></A><H3>
ratioSimilar3</H3>
<PRE>
public double <B>ratioSimilar3</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
                            <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
                            java.io.PrintStream&nbsp;log)</PRE>
<DL>
<DD>Perform an <b>Averaged Search Similarity</b><br>
 <p>Similar to Basic Search Similarity, except<br><br>
 <pre>penalty = (sum{min{shortestDist(l[i], r), 5}} +
       &nbsp;          sum{min{shortestDist(r[j], l), 5}}
       &nbsp;         ) / (|lu| + |ru| + 1)</pre>
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g1</CODE> - the 'left' model<DD><CODE>g2</CODE> - the 'right' model<DD><CODE>log</CODE> - if not <code>null</code> where verbose output is sent
<DT><B>Returns:</B><DD>the ratio of similarity for <code>g1</code> and <code>g2</code><DT><B>See Also:</B><DD><A HREF="../foldocml/Similarity.html"><CODE>Similarity</CODE></A>, 
<A HREF="../foldocml/DiffDistance.html"><CODE>DiffDistance</CODE></A>, 
<A HREF="../foldocml/AveragedSearchPenalty.html"><CODE>AveragedSearchPenalty</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ratioSimilar4(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)"><!-- --></A><H3>
ratioSimilar4</H3>
<PRE>
public double <B>ratioSimilar4</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
                            <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
                            java.io.PrintStream&nbsp;log)</PRE>
<DL>
<DD>Perform a <b>Normalised Search Similarity</b><br>
 <p>Similar to Basic Search Similarity, except<br><br>
 <pre>penalty = (sum{min{shortestDist(l[i], r), 5} / 5} +
       &nbsp;          sum{min{shortestDist(r[j], l), 5} / 5})
       </pre>
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g1</CODE> - the 'left' model<DD><CODE>g2</CODE> - the 'right' model<DD><CODE>log</CODE> - if not <code>null</code> where verbose output is sent
<DT><B>Returns:</B><DD>the ratio of similarity for <code>g1</code> and <code>g2</code><DT><B>See Also:</B><DD><A HREF="../foldocml/Similarity.html"><CODE>Similarity</CODE></A>, 
<A HREF="../foldocml/DiffDistance.html"><CODE>DiffDistance</CODE></A>, 
<A HREF="../foldocml/NormalisedSearchPenalty.html"><CODE>NormalisedSearchPenalty</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ratioSimilar5(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)"><!-- --></A><H3>
ratioSimilar5</H3>
<PRE>
public double <B>ratioSimilar5</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
                            <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
                            java.io.PrintStream&nbsp;log)</PRE>
<DL>
<DD>Perform an <b>Averaged Normalised Search Similarity</b><br>
 <p>Similar to Normalised Search Similarity, except<br><br>
 <pre>penalty = 1 - (sum{min{shortestDist(l[i], r), 5} / 5} +
       &nbsp;              sum{min{shortestDist(r[j], l), 5} / 5}
       &nbsp;             ) / (|lu| + |ru| + |lc| + |rc|)</pre>
 </p>
 <ul><li>Unlike the other search methods, this is able to give a final
 'ratio similar' that is in [0, 1], and realistically representative of
 the actual % similar of the graphs</li></ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g1</CODE> - the 'left' model<DD><CODE>g2</CODE> - the 'right' model<DD><CODE>log</CODE> - if not <code>null</code> where verbose output is sent
<DT><B>Returns:</B><DD>the ratio of similarity for <code>g1</code> and <code>g2</code><DT><B>See Also:</B><DD><A HREF="../foldocml/Similarity.html"><CODE>Similarity</CODE></A>, 
<A HREF="../foldocml/DiffDistance.html"><CODE>DiffDistance</CODE></A>, 
<A HREF="../foldocml/AvgNormSearchPenalty.html"><CODE>AvgNormSearchPenalty</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ratioSimilar6(hashgraph.HashGraph, hashgraph.HashGraph, java.io.PrintStream)"><!-- --></A><H3>
ratioSimilar6</H3>
<PRE>
public double <B>ratioSimilar6</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g1,
                            <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;g2,
                            java.io.PrintStream&nbsp;log)</PRE>
<DL>
<DD>Perform a <b>Minimum Spanning Tree Similarity</b><br>
 <p>
 Perhaps surprising in its simplicity, but also surprising in its effectiveness.
 This method simple merges <code>g1</code> and <code>g2</code>, into
 <code>g3</code>, say. Then computes minimum spanning trees for all three
 models and sums the edge weights of each tree: <code>w1, w2, w3</code>, say.
 Then,
 <pre>similarity = ((w1 + w2) / (2 * w3)  -  0.5) * 2</pre>
 </p><p>
 The logic is this: <pre>
avg{w1, w2} = (w1 + w2)/2 &lt;= w3 &lt;= (w1 + w2)
so
0.5 &lt;= (w1 + w2) / (2 * w3) &lt;= 1.0</pre>
 and where the value lies in this range has some reflection on the similarity
 of the two models
 </p><p>
 The potential runtime using Prim's algorithm and Fibonnacci heaps is
 O(|g3|*lg(|g3|)), but until I implement these in Java the current
 runtime is more like O(|g3|*|g3|)
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g1</CODE> - the 'left' model<DD><CODE>g2</CODE> - the 'right' model<DD><CODE>log</CODE> - if not <code>null</code> where verbose output is sent
<DT><B>Returns:</B><DD>the ratio of similarity for <code>g1</code> and <code>g2</code><DT><B>See Also:</B><DD><A HREF="../foldocml/SpanSimilar.html"><CODE>SpanSimilar</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../foldocml/AvgNormSearchPenalty.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../foldocml/DiffDistance.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Connection.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
