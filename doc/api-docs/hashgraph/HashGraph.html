<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Wed Feb 26 14:50:58 EST 2003 -->
<TITLE>
HashGraph
</TITLE>
<META NAME="keywords" CONTENT="hashgraph.HashGraph,HashGraph class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="HashGraph";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../hashgraph/HashGraph.LinkIterator.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="HashGraph.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
hashgraph</FONT>
<BR>
Class HashGraph</H2>
<PRE>
java.lang.Object
  |
  +--<B>hashgraph.HashGraph</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable, java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT>public class <B>HashGraph</B><DT>extends java.lang.Object<DT>implements java.lang.Cloneable, java.io.Serializable</DL>

<P>
<p>A general weighted digraph structure with hash table lookup</p>
 <p>Represents a set of Nodes and the links between them</p>
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>1.0</DD>
<DT><B>Author:</B></DT>
  <DD>Trent Apted</DD>
<DT><B>See Also:</B><DD><A HREF="../serialized-form.html" TARGET="hashgraph.HashGraph">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.LinkIterator.html">HashGraph.LinkIterator</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A nested class implementing an Iterator over the <code>Link</code>s in the graph</TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#FLAG_BACK_LINK">FLAG_BACK_LINK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag: wether to process backward links</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#MERGE_COMMON">MERGE_COMMON</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flags for temp variable of Nodes to indicate merge source</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#MERGE_OTHER">MERGE_OTHER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flags for temp variable of Nodes to indicate merge source</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#MERGE_THIS">MERGE_THIS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flags for temp variable of Nodes to indicate merge source</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#modCount">modCount</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tracks the state for failfast iterators; incremented for each removal or insertion</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#HashGraph()">HashGraph</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new, empty HashGraph</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#HashGraph(int)">HashGraph</A></B>(int&nbsp;initialCapacity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new, empty HashGraph, with initial _node_ capacity</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/Node.html">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#add(java.lang.String)">add</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.HashMap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#allCosts(hashgraph.Node)">allCosts</A></B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <code>HashMap</code> from <code>Node</code>s to <code>Integer</code>s</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.HashMap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#allPaths(hashgraph.Node)">allPaths</A></B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the shortest paths from n to all other nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#averageWeights()">averageWeights</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#avgavgPeers()">avgavgPeers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear the network of all Nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#clone()">clone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a <b><i>deep </b></i> copy of this graph</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#contains(java.lang.Object)">contains</A></B>(java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests if a specific Node object exists in the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#copyLinks(hashgraph.HashGraph)">copyLinks</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;from)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get as many links as possible from <code>from</code> that include nodes in <code>this</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#cost(hashgraph.Node, hashgraph.Node)">cost</A></B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n1,
     <A HREF="../hashgraph/Node.html">Node</A>&nbsp;n2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives the total (minimum) cost time between two given nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#cost(java.lang.String, java.lang.String)">cost</A></B>(java.lang.String&nbsp;key1,
     java.lang.String&nbsp;key2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives the total (minimum) cost between two given nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#costIntersect(hashgraph.HashGraph)">costIntersect</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intersect with another HashGraph, adding costs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#costMerge(hashgraph.HashGraph, double)">costMerge</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;other,
          double&nbsp;infinity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;costMerge/3 with thisInf = otherInf = infinity</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#costMerge(hashgraph.HashGraph, double, double)">costMerge</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;other,
          double&nbsp;thisInf,
          double&nbsp;otherInf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge with another HashGraph, adding costs when shared or infinity if not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#density()">density</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the number of links in the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#depthgrow(java.util.Iterator, double)">depthgrow</A></B>(java.util.Iterator&nbsp;target,
          double&nbsp;ddepth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/Node.html">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#get(java.lang.Object)">get</A></B>(java.lang.Object&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a node from the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/Node.html">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#getAddNode(java.lang.String)">getAddNode</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Always succeeds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Collection</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#getNodes()">getNodes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the nodes collection</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#grow(java.util.Iterator, double)">grow</A></B>(java.util.Iterator&nbsp;target,
     double&nbsp;amount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#grow(java.util.Iterator, double, int)">grow</A></B>(java.util.Iterator&nbsp;target,
     double&nbsp;amount,
     int&nbsp;maxNodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Grow <code>target</code> using <code>this</code> the specified <code>amount</code>
 as if it were a model to include concepts related to <code>target</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#isEmpty()">isEmpty</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wether the HashGraph is empty</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#isReachable(hashgraph.Node, hashgraph.Node)">isReachable</A></B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n1,
            <A HREF="../hashgraph/Node.html">Node</A>&nbsp;n2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests if one node is reachable from another.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#isReachable(java.lang.String, java.lang.String)">isReachable</A></B>(java.lang.String&nbsp;key1,
            java.lang.String&nbsp;key2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests if one node is reachable from another.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#linkIterator()">linkIterator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a link iterator for forward links in the graph</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#merge(hashgraph.HashGraph)">merge</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge and link this with other</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#merge(hashgraph.HashGraph, boolean)">merge</A></B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;other,
      boolean&nbsp;link)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge <code>this</code> with another HashGraph, ignoring costs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#minDistance(hashgraph.Node, hashgraph.HashGraph)">minDistance</A></B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n,
            <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minDistance with infinity maxDistance</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#minDistance(hashgraph.Node, hashgraph.HashGraph, double)">minDistance</A></B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n,
            <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;to,
            double&nbsp;maxDistance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Looks for the minimum distance from n (a node in this HashGraph)
 to any node in 'to' (a subgraph of this HashGraph)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#minSpanWeight()">minSpanWeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a minimum spanning tree and return the sum of its link weights</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#nodeIterator()">nodeIterator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a node iterator for the graph</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#path(hashgraph.Node, hashgraph.Node)">path</A></B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n1,
     <A HREF="../hashgraph/Node.html">Node</A>&nbsp;n2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the shortest path between two nodes on the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#path(java.lang.String, java.lang.String)">path</A></B>(java.lang.String&nbsp;key1,
     java.lang.String&nbsp;key2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the shortest path between two nodes on the graph</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#progReadInt(java.io.ObjectInputStream)">progReadInt</A></B>(java.io.ObjectInputStream&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read a progressively encoded 32-bit int from in</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#progWriteInt(java.io.ObjectOutputStream, int)">progWriteInt</A></B>(java.io.ObjectOutputStream&nbsp;out,
             int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Progressively encode a 32-bit int and write it to out - must be less than 2^30</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#readData(java.io.ObjectInputStream)">readData</A></B>(java.io.ObjectInputStream&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deserialise into <code>this</code> without progress posts</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#readData(java.io.ObjectInputStream, foldocui.Poster)">readData</A></B>(java.io.ObjectInputStream&nbsp;in,
         <A HREF="../foldocui/Poster.html">Poster</A>&nbsp;post)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deserialise into <code>this</code> with progress posts to <code>post</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#remove(java.lang.Object)">remove</A></B>(java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove a given Node and its links from the graph</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for loading to make sure paths are redone</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#size()">size</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the number of nodes in the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#sizegrow(java.util.Iterator, double)">sizegrow</A></B>(java.util.Iterator&nbsp;target,
         double&nbsp;maxNodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../hashgraph/HashGraph.html">HashGraph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#subgraph(java.lang.String, double)">subgraph</A></B>(java.lang.String&nbsp;key,
         double&nbsp;dist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve a subgraph with all nodes within cost <code>dist</code>ance
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string representation of this network:</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../hashgraph/HashGraph.html#writeData(java.io.ObjectOutputStream)">writeData</A></B>(java.io.ObjectOutputStream&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serialise this graph to out</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="MERGE_COMMON"><!-- --></A><H3>
MERGE_COMMON</H3>
<PRE>
public static final short <B>MERGE_COMMON</B></PRE>
<DL>
<DD>Flags for temp variable of Nodes to indicate merge source
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../constant-values.html#hashgraph.HashGraph.MERGE_COMMON">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MERGE_THIS"><!-- --></A><H3>
MERGE_THIS</H3>
<PRE>
public static final short <B>MERGE_THIS</B></PRE>
<DL>
<DD>Flags for temp variable of Nodes to indicate merge source
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../constant-values.html#hashgraph.HashGraph.MERGE_THIS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MERGE_OTHER"><!-- --></A><H3>
MERGE_OTHER</H3>
<PRE>
public static final short <B>MERGE_OTHER</B></PRE>
<DL>
<DD>Flags for temp variable of Nodes to indicate merge source
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../constant-values.html#hashgraph.HashGraph.MERGE_OTHER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FLAG_BACK_LINK"><!-- --></A><H3>
FLAG_BACK_LINK</H3>
<PRE>
public static boolean <B>FLAG_BACK_LINK</B></PRE>
<DL>
<DD>Flag: wether to process backward links
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="modCount"><!-- --></A><H3>
modCount</H3>
<PRE>
protected int <B>modCount</B></PRE>
<DL>
<DD>Tracks the state for failfast iterators; incremented for each removal or insertion
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="HashGraph()"><!-- --></A><H3>
HashGraph</H3>
<PRE>
public <B>HashGraph</B>()</PRE>
<DL>
<DD>Create a new, empty HashGraph
<P>
</DL>
<HR>

<A NAME="HashGraph(int)"><!-- --></A><H3>
HashGraph</H3>
<PRE>
public <B>HashGraph</B>(int&nbsp;initialCapacity)</PRE>
<DL>
<DD>Create a new, empty HashGraph, with initial _node_ capacity
<P>
<DT><B>Parameters:</B><DD><CODE>initialCapacity</CODE> - the intial capacity</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="getAddNode(java.lang.String)"><!-- --></A><H3>
getAddNode</H3>
<PRE>
public <A HREF="../hashgraph/Node.html">Node</A> <B>getAddNode</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Always succeeds. Returns a node for key in this graph.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.String)"><!-- --></A><H3>
add</H3>
<PRE>
public <A HREF="../hashgraph/Node.html">Node</A> <B>add</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Add a node. Returns a previous mapping if any.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>()</PRE>
<DL>
<DD>Clear the network of all Nodes.<p>
 O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="contains(java.lang.Object)"><!-- --></A><H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(java.lang.Object&nbsp;o)</PRE>
<DL>
<DD>Tests if a specific Node object exists in the network.<p>
 O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o</CODE> - the Node or key to perform the test on.
<DT><B>Returns:</B><DD>true if the Node exists</DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.Object)"><!-- --></A><H3>
get</H3>
<PRE>
public <A HREF="../hashgraph/Node.html">Node</A> <B>get</B>(java.lang.Object&nbsp;key)</PRE>
<DL>
<DD>Get a node from the network.<p>
 O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the node object corresponding to the key (word)</DL>
</DD>
</DL>
<HR>

<A NAME="getNodes()"><!-- --></A><H3>
getNodes</H3>
<PRE>
public java.util.Collection <B>getNodes</B>()</PRE>
<DL>
<DD>Return the nodes collection
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>Collection</code> of <code>Node</code></DL>
</DD>
</DL>
<HR>

<A NAME="isEmpty()"><!-- --></A><H3>
isEmpty</H3>
<PRE>
public boolean <B>isEmpty</B>()</PRE>
<DL>
<DD>Wether the HashGraph is empty
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if there are no links or nodes</DL>
</DD>
</DL>
<HR>

<A NAME="isReachable(java.lang.String, java.lang.String)"><!-- --></A><H3>
isReachable</H3>
<PRE>
public boolean <B>isReachable</B>(java.lang.String&nbsp;key1,
                           java.lang.String&nbsp;key2)</PRE>
<DL>
<DD>Tests if one node is reachable from another.<p>
 Will check if a path of connections exists between the two nodes.<p>
 O(n); density() (number of links) - doesn't bother with the priority queue<p>
 However, if a previous dijkstra's or reachable labelling has been done
 without a node being added or deleted since, there will be an early exit if
 both nodes are already labelled (not with infinity) as they must
 necessarily be connected for either algorithm to label them.
 Also if it was a dijkstra's (and only dijkstra's) it will exit early if one
 is labelled and the other is not (returning false), as they cannot be connected.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key1</CODE> - <DD><CODE>key2</CODE> - 
<DT><B>Returns:</B><DD>true if a path of connections exist between the nodes.</DL>
</DD>
</DL>
<HR>

<A NAME="isReachable(hashgraph.Node, hashgraph.Node)"><!-- --></A><H3>
isReachable</H3>
<PRE>
public boolean <B>isReachable</B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n1,
                           <A HREF="../hashgraph/Node.html">Node</A>&nbsp;n2)</PRE>
<DL>
<DD>Tests if one node is reachable from another.  Will check if a path of connections exists between the two nodes.

 Algorithm:<p>
 Start at ip1, label it and all nodes connected to it arbitrarily
 if ip2 is labelled at any time then it is reachable from ip1<p>
 O(n) on the number of links
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n1</CODE> - the first node.<DD><CODE>n2</CODE> - the second node.
<DT><B>Returns:</B><DD>true if a path of connections exist between the nodes.</DL>
</DD>
</DL>
<HR>

<A NAME="nodeIterator()"><!-- --></A><H3>
nodeIterator</H3>
<PRE>
public java.util.Iterator <B>nodeIterator</B>()</PRE>
<DL>
<DD>Returns a node iterator for the graph<p>
 O(1) - backed by the HashMap of nodes.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an iterator for the nodes in the network.</DL>
</DD>
</DL>
<HR>

<A NAME="linkIterator()"><!-- --></A><H3>
linkIterator</H3>
<PRE>
public java.util.Iterator <B>linkIterator</B>()</PRE>
<DL>
<DD>Returns a link iterator for forward links in the graph<p>
 O(1);
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an iterator for the links in the network.</DL>
</DD>
</DL>
<HR>

<A NAME="path(java.lang.String, java.lang.String)"><!-- --></A><H3>
path</H3>
<PRE>
public java.util.List <B>path</B>(java.lang.String&nbsp;key1,
                           java.lang.String&nbsp;key2)</PRE>
<DL>
<DD>Returns the shortest path between two nodes on the graph
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key1</CODE> - <DD><CODE>key2</CODE> - 
<DT><B>Returns:</B><DD>a List with each Node object in the path stored in order in the list.<DT><B>See Also:</B><DD><CODE>#storePaths(Node, double, HashGraph)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="path(hashgraph.Node, hashgraph.Node)"><!-- --></A><H3>
path</H3>
<PRE>
public java.util.List <B>path</B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n1,
                           <A HREF="../hashgraph/Node.html">Node</A>&nbsp;n2)</PRE>
<DL>
<DD>Returns the shortest path between two nodes on the network.<p>
 Checks to see if the current labelling can be used before running dijkstra's
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n1</CODE> - the first node.<DD><CODE>n2</CODE> - the second node.
<DT><B>Returns:</B><DD>a List with each Link object in the path stored in order in the list.<br>
 If n1 = n2 returns an empty List<br>
 If n1 is not reachable from n2 returns null<br>
 Otherwise returns a list of Link objects from n1 to n2<DT><B>See Also:</B><DD><CODE>#storePaths(Node, double, HashGraph)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="allPaths(hashgraph.Node)"><!-- --></A><H3>
allPaths</H3>
<PRE>
public java.util.HashMap <B>allPaths</B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n)</PRE>
<DL>
<DD>Finds the shortest paths from n to all other nodes.<p>
 Cheks to see if current labelling can be used before running dijkstra's<p>
 Only maps those nodes reachable from n, so: <p>
 <pre>
 allCosts(srcNode).containsKey(destNode) %lt;=&gt; isReachable(srcNode, destNode)
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the source node
<DT><B>Returns:</B><DD>a HashMap mapping nodeKeys (Integer or String) to <code>Path</code>s,
		the cost of going from n to the key along the shortest path<DT><B>See Also:</B><DD><CODE>#storePaths(Node, double, HashGraph)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="allCosts(hashgraph.Node)"><!-- --></A><H3>
allCosts</H3>
<PRE>
public java.util.HashMap <B>allCosts</B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n)</PRE>
<DL>
<DD>Returns a <code>HashMap</code> from <code>Node</code>s to <code>Integer</code>s<p>
 The mapping is it's key's shortest path cost from <code>n</code>.<p>
 Checks to see if the current labelling can be used before running dijkstra's
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the source node from which to calculate all costs
<DT><B>Returns:</B><DD>a <code>HashMap</code> from <code>Node</code>s to <code>Integer</code>s<DT><B>See Also:</B><DD><CODE>#storePaths(Node, double, HashGraph)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="clone()"><!-- --></A><H3>
clone</H3>
<PRE>
public java.lang.Object <B>clone</B>()
                       throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Return a <b><i>deep </b></i> copy of this graph
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>clone</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>HashGraph</code> duplicate of this
<DT><B>Throws:</B>
<DD><CODE>java.lang.CloneNotSupportedException</CODE> - not thrown</DL>
</DD>
</DL>
<HR>

<A NAME="depthgrow(java.util.Iterator, double)"><!-- --></A><H3>
depthgrow</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>depthgrow</B>(java.util.Iterator&nbsp;target,
                           double&nbsp;ddepth)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sizegrow(java.util.Iterator, double)"><!-- --></A><H3>
sizegrow</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>sizegrow</B>(java.util.Iterator&nbsp;target,
                          double&nbsp;maxNodes)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="grow(java.util.Iterator, double)"><!-- --></A><H3>
grow</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>grow</B>(java.util.Iterator&nbsp;target,
                      double&nbsp;amount)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="grow(java.util.Iterator, double, int)"><!-- --></A><H3>
grow</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>grow</B>(java.util.Iterator&nbsp;target,
                      double&nbsp;amount,
                      int&nbsp;maxNodes)</PRE>
<DL>
<DD>Grow <code>target</code> using <code>this</code> the specified <code>amount</code>
 as if it were a model to include concepts related to <code>target</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - the model to grow<DD><CODE>amount</CODE> - the amount to grow it
<DT><B>Returns:</B><DD>the grown model<DT><B>See Also:</B><DD><A HREF="../foldocml/Connection.html#grow(java.util.Iterator, double)"><CODE>Connection.grow(Iterator words, double depth)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cost(java.lang.String, java.lang.String)"><!-- --></A><H3>
cost</H3>
<PRE>
public double <B>cost</B>(java.lang.String&nbsp;key1,
                   java.lang.String&nbsp;key2)</PRE>
<DL>
<DD>Gives the total (minimum) cost between two given nodes.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key1</CODE> - <DD><CODE>key2</CODE> - 
<DT><B>Returns:</B><DD>the ping between the two nodes.<DT><B>See Also:</B><DD><CODE>#storePaths(Node, double, HashGraph)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cost(hashgraph.Node, hashgraph.Node)"><!-- --></A><H3>
cost</H3>
<PRE>
public double <B>cost</B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n1,
                   <A HREF="../hashgraph/Node.html">Node</A>&nbsp;n2)</PRE>
<DL>
<DD>Gives the total (minimum) cost time between two given nodes.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n1</CODE> - the first node.<DD><CODE>n2</CODE> - the second node.
<DT><B>Returns:</B><DD>the cost between the two nodes.
 returns -1 if no path exists between n1 & n2
 return 0 if n1 = n2</DL>
</DD>
</DL>
<HR>

<A NAME="remove(java.lang.Object)"><!-- --></A><H3>
remove</H3>
<PRE>
public boolean <B>remove</B>(java.lang.Object&nbsp;o)</PRE>
<DL>
<DD>Remove a given Node and its links from the graph<p>
 O(n) to remove a node (n = #links to/from o; &lt; size() AND &lt;&lt; density())<p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>false if no such Node exists in the graph.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - the object is neither a key nor a Node.</DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
public int <B>size</B>()</PRE>
<DL>
<DD>Return the number of nodes in the network.<p>
 O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of nodes in the network.</DL>
</DD>
</DL>
<HR>

<A NAME="density()"><!-- --></A><H3>
density</H3>
<PRE>
public int <B>density</B>()</PRE>
<DL>
<DD>Return the number of links in the network.
 Does not include backward links.
 O(n); number of nodes
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of links in the network.</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Returns a string representation of this network:<p>
 Lists all the nodes first, each on a new line, followed by all the links
 (each on a new line)<p>

 O(n) - max {size(). density()}
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="merge(hashgraph.HashGraph, boolean)"><!-- --></A><H3>
merge</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>merge</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;other,
                       boolean&nbsp;link)</PRE>
<DL>
<DD>Merge <code>this</code> with another HashGraph, ignoring costs.
 Performs a shallow copy.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - the otehr graph to merge<DD><CODE>link</CODE> - wether to [shallow] copy links
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="merge(hashgraph.HashGraph)"><!-- --></A><H3>
merge</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>merge</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;other)</PRE>
<DL>
<DD>Merge and link this with other
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - the other graph to merge
<DT><B>Returns:</B><DD>the merged graph</DL>
</DD>
</DL>
<HR>

<A NAME="copyLinks(hashgraph.HashGraph)"><!-- --></A><H3>
copyLinks</H3>
<PRE>
public void <B>copyLinks</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;from)</PRE>
<DL>
<DD>Get as many links as possible from <code>from</code> that include nodes in <code>this</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>from</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="costMerge(hashgraph.HashGraph, double, double)"><!-- --></A><H3>
costMerge</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>costMerge</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;other,
                           double&nbsp;thisInf,
                           double&nbsp;otherInf)</PRE>
<DL>
<DD>Merge with another HashGraph, adding costs when shared or infinity if not.
 Performs a DEEP copy: so that links can be maintained
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - the other graph to merge<DD><CODE>thisInf</CODE> - the penalty for a disjoint node originating from <code>this</code><DD><CODE>otherInf</CODE> - the penalty for a disjoint node originating from <code>other</code>
<DT><B>Returns:</B><DD>the merged model</DL>
</DD>
</DL>
<HR>

<A NAME="costMerge(hashgraph.HashGraph, double)"><!-- --></A><H3>
costMerge</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>costMerge</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;other,
                           double&nbsp;infinity)</PRE>
<DL>
<DD>costMerge/3 with thisInf = otherInf = infinity
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - <DD><CODE>infinity</CODE> - = otherInf = thisInf
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="costIntersect(hashgraph.HashGraph)"><!-- --></A><H3>
costIntersect</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>costIntersect</B>(<A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;other)</PRE>
<DL>
<DD>Intersect with another HashGraph, adding costs.
 Performs a DEEP copy: so that links can be maintained
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - the graph to find common nodes with
<DT><B>Returns:</B><DD>the intersection of the graphs</DL>
</DD>
</DL>
<HR>

<A NAME="subgraph(java.lang.String, double)"><!-- --></A><H3>
subgraph</H3>
<PRE>
public <A HREF="../hashgraph/HashGraph.html">HashGraph</A> <B>subgraph</B>(java.lang.String&nbsp;key,
                          double&nbsp;dist)</PRE>
<DL>
<DD>Retrieve a subgraph with all nodes within cost <code>dist</code>ance
 <p>
 Performs a DEEP copy: links need to be modified and costs need to be
 maintained as different accross common subgraphs
 </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the start node<DD><CODE>dist</CODE> - the distance to search
<DT><B>Returns:</B><DD>the subgraph generated</DL>
</DD>
</DL>
<HR>

<A NAME="writeData(java.io.ObjectOutputStream)"><!-- --></A><H3>
writeData</H3>
<PRE>
public void <B>writeData</B>(java.io.ObjectOutputStream&nbsp;out)
               throws java.io.IOException</PRE>
<DL>
<DD>Serialise this graph to out
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>out</CODE> - the output of the serialisation
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error</DL>
</DD>
</DL>
<HR>

<A NAME="readData(java.io.ObjectInputStream, foldocui.Poster)"><!-- --></A><H3>
readData</H3>
<PRE>
public void <B>readData</B>(java.io.ObjectInputStream&nbsp;in,
                     <A HREF="../foldocui/Poster.html">Poster</A>&nbsp;post)
              throws java.io.IOException,
                     java.lang.ClassNotFoundException</PRE>
<DL>
<DD>Deserialise into <code>this</code> with progress posts to <code>post</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>in</CODE> - the serialsed input<DD><CODE>post</CODE> - the <code>Poster</code> to which progress updates are sent
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error
<DD><CODE>java.lang.ClassNotFoundException</CODE> - not thrown</DL>
</DD>
</DL>
<HR>

<A NAME="readData(java.io.ObjectInputStream)"><!-- --></A><H3>
readData</H3>
<PRE>
public void <B>readData</B>(java.io.ObjectInputStream&nbsp;in)
              throws java.io.IOException,
                     java.lang.ClassNotFoundException</PRE>
<DL>
<DD>Deserialise into <code>this</code> without progress posts
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>in</CODE> - the serialsed input
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error
<DD><CODE>java.lang.ClassNotFoundException</CODE> - not thrown</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>()</PRE>
<DL>
<DD>for loading to make sure paths are redone
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="minDistance(hashgraph.Node, hashgraph.HashGraph, double)"><!-- --></A><H3>
minDistance</H3>
<PRE>
public double <B>minDistance</B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n,
                          <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;to,
                          double&nbsp;maxDistance)</PRE>
<DL>
<DD>Looks for the minimum distance from n (a node in this HashGraph)
 to any node in 'to' (a subgraph of this HashGraph)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the start node<DD><CODE>to</CODE> - the target graph<DD><CODE>maxDistance</CODE> - the maximum path length =&gt; an early exit
<DT><B>Returns:</B><DD>the distance or -1 if no path</DL>
</DD>
</DL>
<HR>

<A NAME="minDistance(hashgraph.Node, hashgraph.HashGraph)"><!-- --></A><H3>
minDistance</H3>
<PRE>
public double <B>minDistance</B>(<A HREF="../hashgraph/Node.html">Node</A>&nbsp;n,
                          <A HREF="../hashgraph/HashGraph.html">HashGraph</A>&nbsp;to)</PRE>
<DL>
<DD>minDistance with infinity maxDistance
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../hashgraph/HashGraph.html#minDistance(hashgraph.Node, hashgraph.HashGraph, double)"><CODE>minDistance(Node, HashGraph, double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="minSpanWeight()"><!-- --></A><H3>
minSpanWeight</H3>
<PRE>
public double <B>minSpanWeight</B>()</PRE>
<DL>
<DD>Generate a minimum spanning tree and return the sum of its link weights
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the weigth sum</DL>
</DD>
</DL>
<HR>

<A NAME="progReadInt(java.io.ObjectInputStream)"><!-- --></A><H3>
progReadInt</H3>
<PRE>
public static int <B>progReadInt</B>(java.io.ObjectInputStream&nbsp;in)
                       throws java.io.IOException</PRE>
<DL>
<DD>Read a progressively encoded 32-bit int from in
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>in</CODE> - the input
<DT><B>Returns:</B><DD>the next progInt on in
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on an IO error</DL>
</DD>
</DL>
<HR>

<A NAME="progWriteInt(java.io.ObjectOutputStream, int)"><!-- --></A><H3>
progWriteInt</H3>
<PRE>
public static void <B>progWriteInt</B>(java.io.ObjectOutputStream&nbsp;out,
                                int&nbsp;val)
                         throws java.io.IOException</PRE>
<DL>
<DD>Progressively encode a 32-bit int and write it to out - must be less than 2^30
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>out</CODE> - where to write the progInt<DD><CODE>val</CODE> - the int to encode/write
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - on a IO error
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if val is too big to encode</DL>
</DD>
</DL>
<HR>

<A NAME="averageWeights()"><!-- --></A><H3>
averageWeights</H3>
<PRE>
public double <B>averageWeights</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="avgavgPeers()"><!-- --></A><H3>
avgavgPeers</H3>
<PRE>
public double <B>avgavgPeers</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../hashgraph/HashGraph.LinkIterator.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="HashGraph.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
